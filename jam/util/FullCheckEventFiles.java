/***************************************************************
 * Nuclear Simulation Java Class Libraries
 * Copyright (C) 2003 Yale University
 * 
 * Original Developer
 *     Dale Visser (dale@visser.name)
 * 
 * OSI Certified Open Source Software
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the University of Illinois/NCSA 
 * Open Source License.
 * 
 * This program is distributed in the hope that it will be 
 * useful, but without any warranty; without even the implied 
 * warranty of merchantability or fitness for a particular 
 * purpose. See the University of Illinois/NCSA Open Source 
 * License for more details.
 * 
 * You should have received a copy of the University of 
 * Illinois/NCSA Open Source License along with this program; if 
 * not, see http://www.opensource.org/
 **************************************************************/
package jam.util;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;

/** 
 * This program will check event files of the type generated by
 * jam.sort.stream.YaleCAEN_InputStream for the presence of the buggy behavior
 * whereby the last buffer from the previous run gets put as the first buffer as
 * the next run. Give it a directory and it will print which event files have a
 * first buffer with and end-of-run character at the end of it.
 * 
 * @author Dale Visser
 * @version 6 August 2002
 */
public class FullCheckEventFiles {

	private FullCheckEventFiles(File dir) {

		File[] eventFiles = getEventFiles(dir);
		if (eventFiles.length > 0) {
			System.out.println("Found event files, starting to examine...");
			checkAllBuffers(eventFiles);
		} else {
			System.out.println("Didn't find event files in " + dir);
		}
		System.out.println("Done.");
	}

	private void checkAllBuffers(File[] eventFiles) {
		for (int i = 0; i < eventFiles.length; i++) {
			int initialBytesToSkip = 256 + 8192 - 4;
			int usualBytesToSkip = 8192 - 4;
			System.out.println("Checking File " + eventFiles[i]);
			try {
				DataInputStream instream = new DataInputStream(
						new BufferedInputStream(new FileInputStream(
								eventFiles[i])));
				/* skip header and all but last word of first data buffer */
				boolean skipSuccess = (((long) initialBytesToSkip) == instream
						.skip(initialBytesToSkip));
				int bufferNum = 0;
				if (skipSuccess) {
					bufferNum++;
					int word = instream.readInt();
					if (word == 0x01EEEEEE) { //end-of-run word
						System.out.println("Buffer " + bufferNum
								+ " contains end-of-run-word.");
					}
				}
				while (skipSuccess) {
					skipSuccess = (usualBytesToSkip == instream
							.skipBytes(usualBytesToSkip));
					if (skipSuccess) {
						bufferNum++;
						int word = instream.readInt();
						if (word == 0x01EEEEEE) { //end-of-run word
							System.out.println("Buffer " + bufferNum
									+ " contains end-of-run-word.");
						}
					}
				}
				instream.close();
			} catch (IOException e) {
				System.err.println(e);
			}
		}
	}

	private File[] getEventFiles(File path) {
		return path.listFiles(new FilenameFilter() {
			public boolean accept(File dir, String name) {
				return name.endsWith("evn");
			}
		});
	}

	static private File getDir(String dir) {
		File rval = new File(dir);
		if (rval.exists()) {
			if (!rval.isDirectory())
				rval = rval.getParentFile();
			return rval;
		}
		return null;
	}

	/**
	 * @param args
	 *            one argument--directory where event files are to be checked
	 */
	public static void main(String[] args) {
		boolean printHelp = false;
		if (args.length >= 1) {
			File f1 = getDir(args[0]);
			/*
			 * File f2 = getDir(args[1]); if (f1 == null || f2 == null) {
			 * printHelp = true; } else {
			 */
			new FullCheckEventFiles(f1);
			//}
		} else {
			printHelp = true;
		}
		if (printHelp) {
			System.out.println("CheckEventFiles needs 1 argument:");
			System.out.println("\t1st arg: directory containing event files");
			//System.out.println("\t2nd arg: directory for output files");
		}
	}
}