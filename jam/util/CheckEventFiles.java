/***************************************************************
 * Nuclear Simulation Java Class Libraries
 * Copyright (C) 2003 Yale University
 * 
 * Original Developer
 *     Dale Visser (dale@visser.name)
 * 
 * OSI Certified Open Source Software
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the University of Illinois/NCSA 
 * Open Source License.
 * 
 * This program is distributed in the hope that it will be 
 * useful, but without any warranty; without even the implied 
 * warranty of merchantability or fitness for a particular 
 * purpose. See the University of Illinois/NCSA Open Source 
 * License for more details.
 * 
 * You should have received a copy of the University of 
 * Illinois/NCSA Open Source License along with this program; if 
 * not, see http://www.opensource.org/
 **************************************************************/
package jam.util;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.logging.ConsoleHandler;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This program will check event files of the type generated by
 * jam.sort.stream.YaleCAEN_InputStream for the presence of the buggy behavior
 * whereby the last buffer from the previous run gets put as the first buffer as
 * the next run. Give it a directory and it will print which event files have a
 * first buffer with and end-of-run character at the end of it.
 * 
 * @author Dale Visser
 * @version 6 August 2002
 */
public class CheckEventFiles {

	private static final Logger logger = Logger.getLogger("jam.sort.stream");

	static private File getDir(final String dir) {
		File rval = new File(dir);
		if (rval.exists()) {
			if (!rval.isDirectory()) {
				rval = rval.getParentFile();
			}
		} else {
			rval = null;
		}
		return null;
	}

	/**
	 * @param args
	 *            one argument--directory where event files are to be checked
	 */
	public static void main(final String[] args) {
		boolean printHelp = false;
		if (args.length >= 2) {
			final File file1 = getDir(args[0]);
			final File file2 = getDir(args[1]);
			if (file1 == null || file2 == null) {
				printHelp = true;
			} else {
				new CheckEventFiles(file1, file2);
			}
		} else {
			printHelp = true;
		}
		if (printHelp) {
			System.out.println("CheckEventFiles needs 2 arguments:");
			System.out.println("\t1st arg: directory containing event files");
			System.out.println("\t2nd arg: directory for output files");
		}
	}

	private CheckEventFiles(File dir, File outDir) {
		super();
		try {
			logger.addHandler(new FileHandler());
			logger.addHandler(new ConsoleHandler());
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
		File[] eventFiles = getEventFiles(dir);
		if (eventFiles.length > 0) {
			logger.info("Found event files, starting to examine...");
			checkFirstBuffer(eventFiles);
			makeScalerSummaries(eventFiles, outDir);
		} else {
			logger.warning("Didn't find event files in " + dir);
		}
		logger.info("Done.");
	}

	private void checkFirstBuffer(final File[] eventFiles) {
		for (int i = 0; i < eventFiles.length; i++) {
			final int bytesToSkip = 256 + 8192 - 4;
			logger.info("Checking File " + eventFiles[i]);
			try {
				final DataInputStream instream = new DataInputStream(
						new BufferedInputStream(new FileInputStream(
								eventFiles[i])));
				/* skip header and all but last word of first data buffer */
				final boolean skipSuccess = (bytesToSkip == instream
						.skip(bytesToSkip));
				if (skipSuccess) {
					final int word = instream.readInt();
					final String sWord = "0x" + Integer.toHexString(word);
					if (word == 0x01EEEEEE) { // end-of-run word
						logger.info("...[" + sWord + "]...needs fixing");
					} else {
						logger.info("...[" + sWord + "]...OK");
					}
				} else {
					logger
							.warning("...file not long enough for one data buffer");
				}
				instream.close();
			} catch (IOException e) {
				logger.log(Level.SEVERE, e.getMessage(), e);
			}
		}
	}

	private File[] getEventFiles(final File path) {
		return path.listFiles(new FilenameFilter() {
			public boolean accept(File dir, String name) {
				return name.endsWith("evn");
			}
		});
	}

	private void makeScalerSummaries(final File[] infiles, final File outPath) {
		final int SCALER_HEADER = 0x01cccccc;
		DataInputStream fromStream = null;
		FileWriter csvStream = null;
		FileInputStream fromFile;
		File csvFile;
		for (int j = 0; j < infiles.length; j++) {
			try {
				fromFile = new FileInputStream(infiles[j]);
				csvFile = new File(outPath, infiles[j].getName().substring(0,
						infiles[j].getName().lastIndexOf(".evn"))
						+ "_scalers.csv");
				logger.info("Reading file: " + infiles[j].getPath());
				logger.info("Scaler summary in: " + csvFile.getPath());
				fromStream = new DataInputStream(new BufferedInputStream(
						fromFile));
				csvStream = new FileWriter(csvFile);
				// skip header from input stream
				fromStream.skipBytes(256);
				int blockNum = 0;
				int[] lastVal = new int[16];
				int[] val = new int[16];
				while (true) {
					final int readVal = fromStream.readInt();
					if (readVal == SCALER_HEADER) {
						blockNum++;
						final int numScalers = fromStream.readInt();
						if (blockNum == 1) {
							lastVal = new int[numScalers];
							val = new int[numScalers];
							for (int i = 0; i < numScalers; i++){
								lastVal[i] = -1;
							}
						}
						for (int i = 0; i < numScalers; i++) {
							val[i] = fromStream.readInt();
							csvStream.write(Integer.toString(val[i]));
							if (i < numScalers) {
								csvStream.write(",");
							}
							if (val[i] < lastVal[i]) {
								logger
										.info("Scaler " + i
												+ " out of sequence, block "
												+ blockNum);
							}
							lastVal[i] = val[i];
						}
						csvStream.write("\n");
					}
				}
				// System.out.println("End of event file reached. Closing
				// file.");
			} catch (EOFException e) {
				logger
						.warning("EOFException: End of event file reached. Closing file.");
			} catch (IOException e) {
				logger.log(Level.SEVERE, e.getMessage(), e);
			}
			try {
				fromStream.close();
				csvStream.flush();
				csvStream.close();
			} catch (IOException e) {
				logger.log(Level.SEVERE, e.getMessage(), e);
			}

		}
		logger.info("Done.");
	}
}
