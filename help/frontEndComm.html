<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <TITLE>jam Manual--Front End Protocol</TITLE>
   <LINK REL=STYLESHEET TYPE="text/css" HREF="manualstyle.css" TITLE="Manual Style">
</HEAD>
<BODY>
<H2>Front End Protocol</H2>
<p>Jam and the front end computer running the real-time acquisition of data communicate using UDP/IP packets, often referred herein as "datagrams". For simplicity here, the front end computer will be referred to as a VME controller, though it need not be in practice. At University of Washington's <a href="http://www.npl.washington.edu/">CENPA</a>, <a href="mailto:swanson@npl.washington.edu">Erik Swanson</a> has developed a PC-based program to control a CAMAC crate, and which communicates with a local Jam process through these same datagrams.</p>
<h3>Form of host-to-VME Command datagrams</h3>
<table>
<tr>
<td>Bytes</td><td>Item</td>
</tr> 
<tr> 
<td>0-3</td><td>A 4-byte (big endian) signed int indicating the type of packet</td>
</tr>
<tr>
<td>4-80</td><td>A NUL ('\0') terminated string command-line-type command. e.g: <code>command arg1 arg2</code></td>
</tr>
</table>

<h4>Datagrams sent by Jam for "Setup Online"</h4>
<h5>case 1: vmeMap used to define parameters in the sort routine</h5>
<p>In the following table, N is the number of defined parameters, R is the number of TDC's where ranges are specified, baseAddress is the base address of each ADC or TDC given in hexadecimal and prefixed by "0x", unitChannel is the channel within the ADC or TDC to be read, and range is the number to be sent to the range register in the TDC. The quotes around the strings are not actually sent, but a null character is sent immediately after the string.</p>

<p>It is expected that all channels in the ADC's and TDC's <em>other than those defined here</em> will be disabled.</p>
<br>
<table>
    <tr><td>Packet#</td><td>integer</td><td>string</td></tr>
    <tr><td>1</td><td>0</td><td>"debug on" or "debug off", depending on user preferences</td></tr>
    <tr><td>2</td><td>0</td><td>"verbose on" or "verbose off", depending on user preferences</td></tr>
    <tr><td>3</td><td>5</td>
    <td>
    "N<br>
    slot(param1) baseAddress(param1) unitChannel(param1)<br>
    ...
    slot(paramN) baseAddress(paramN) unitChannel(paramN)<br>
    R<br>
    baseAddress(tdc1) range(tdc1)<br>
    ...<br>
    baseAddress(tdcR) range(tdcR)<br>
    "</td></tr>
</table>
<h6>Expected VME response</h6>
<table>
<tr><td>1</td><td>The debug state in the VME code is enabled or disabled. If enabled, the code should print debugging messages to the terminal and/or send debugging messages to Jam to be printed on Jam's console.</td></tr>
<tr><td>2</td><td>Similar to the debug state. Enabling verbosity simply asks for more status messages to be printed to the VME terminal and/or sent to Jam for printing on its console. "verbose off" implies a quiet mode where only the most important messages and also any requested messages are communicated.</td></tr>
<tr><td>3</td><td>All channels in the ADC's and TDC's are disabled, then <em>those defined here</em> will be enabled for conversion. All TDC's with specified ranges will have the given value written to their range register.</td></tr>
</table>
<h5>case 2: cnafCommands used to define parameters and CAMAC commands</h5>

<h4>Datagram sent by Jam when "start" or "Begin" is clicked</h4>
<p>Clicking start simply sends this packet. Clicking Begin will first cause Jam to open an event file, write a header to it, optionally zero the histograms and optionally send a datagram to request the scalers be zeroed, then finally send the packet shown below.</p>
<br>
<table>
<tr><td>integer</td><td>string</td></tr>
<tr><td>0</td><td>"START"</td>
</table>
<h5>Expected VME response</h5>
<p>All modules which have channels enabled will be set to online mode, so that they'll convert the signals at their inputs when they receive gates. Additionally, the scaler module(s) should have its (their) inhibit state removed so that they can count logic pulses.</p>
<h4>Datagram sent by Jam to request zeroing of scalers</h4>
<table>
<tr><td>integer</td><td>string</td></tr>
<tr><td>0</td><td>"count zero"</td>
</table>
<h5>Expected VME response</h5>
<p>All channels in the scaler module(s) should be reset to zero counts.</p>
<h4><a name="readscalers">Datagram sent by Jam to request scaler values</a></h4>
<table>
<tr><td>integer</td><td>string</td></tr>
<tr><td>0</td><td>"list scaler"</td>
</table>
<h5>Expected VME response</h5>
<p>A <a href="#vmetohost">VME-to-host datagram</a> with SCALER status, with the 4-byte status word (0x00000002) followed by N+1 4-byte integers. The first integer is N, the number of scaler values to follow. The first scaler value is assumed to belong to the Scaler defined first in the sort routine, the second value to the second defined Scaler, etc., regardless of the number assigned to the Scaler when it's defined.</p>
<h4>Datagram sent by Jam when "stop" is clicked</h4>
<table>
<tr><td>integer</td><td>string</td></tr>
<tr><td>0</td><td>"STOP"</td>
</table>
<h5>Expected VME response</h5>
<p>Take the ADC's and TDC's offline, and raise the inhibit state on the scaler module(s). Completely read the remaining data in the ADC and TDC buffers, sending final buffer(s) with the data. The last buffer should be padded with <a href="CAENformat.html#padding">STOP_PAD</a>.</p>
<h4>Datagram sent by Jam when "End" is clicked</h4>
<table>
<tr><td>integer</td><td>string</td></tr>
<tr><td>0</td><td>"END"</td>
</table>
<p>This is followed by a sending a <a href="#readscalers">request for scaler values</a>. When Jam is finished sorting the last data buffer, it closes its event file.</p>
<h5>Expected VME response</h5>
<p>Same as stopping, but the last buffer should be padded with <a href="CAENformat.html#padding">END_PAD</a>.</p>

<h3><a name="vmetohost">Form of VME-to-host reply datagrams</a></h3>

<h4>byte 0-3</h4>   
<dl>
<dt>0x00000000</dt>   
<dd>O.K. execution of last command</dd>
<dt>0x00000001</dt>   
<dd>Error in execution of last command</dd>
<dt>0x00000002</dt>
<dd>Scaler reply packet</dd>
<dt>0x00000003</dt>
<dd>CNAF reply packet</dd>
</dl>
                                                  
<h4>Message reply datagram (0 or 1)</h4>			
<dl><dt>bytes 4-80</dt>
<dd>NUL-terminated string containing either a message notifying of successful Host-to-VME call and execution or an error message as appropriate.</dd>
</dl>

<h4>Scaler reply datagram (2)</h4>
<table>
<tr>
<td>Bytes</td><td>Item</td>
</tr>
<tr>
<td>4-7</td><td>Number of scalers read</td>
</tr>
<tr>
<td>8 - 11</td><td>Value of scaler 0</td>
</tr>
<tr>
<td>12 - 15</td><td>Value of scaler 1</td>
</tr>
<tr>
<td>... - ...</td><td>...</td>
</tr>
<tr>
<td>8+nx4 - 11+nx4</td><td>Value of scaler n-1</td>
</tr>
</table>

<h4>CNAF reply datagram (3)</h4>
<table>
<tr>
<td>Bytes</td><td>Item</td>
</tr>
<tr>
<td>4-7</td><td>n  Read value</td>
</tr>
</table>
         	
<h2>Commands</h2>
<p>Note: Commands and arguments <em>are</em> case-sensitive.</p>
<p><a name="note">*</a> - indicates command not yet implemented</p>	

<dl>
<dt><code>cnaf init</code></dt>
<dd>Load a list of the CNAFs to perform when a CAMAC crate initialization is done.</dd>

<dt><code>cnaf event</code></dt>
<dd>Load a list of the CNAFs to perform for each event. Installed under interrupt #2 from CBD.</dd>

<dt><code>cnaf scaler</code></dt>
<dd>Load a list of CNAFs to perform to when a scaler read is requested.</dd>
                  
<dt><code>cnaf clear</code></dt>
<dd>Load a list of CNAFs to perform to clear the crate, when a run is started.</dd>

<dt><code>list init</code></dt>
<dd>Initialize the Camac crate and any VME modules that need to be, and execute the init CNAFS.</dd>

<dt><code>list event</code></dt>
<dd>Read an event using the event CNAFs as if a event interrupt had occured. This is useful for debugging.</dd>
                  
<dt><code>list scaler</code></dt>
<dd>Read the scaler values, using scaler CNAFs.</dd>
			
<dt><code>list clear</code></dt>
<dd>Execute the clear list CNAF, used to clear before a run,
						usually just zeros the scalers.</dd>
			
<dt><code>START</code></dt>
<dd>Start the data acquisition.</dd> 

<dt><code>STOP</code></dt>
<dd>Stop the data acquisition, and flush out the data buffer.</dd>
                  
<dt><code>END</code></dt>
<dd>Stop data acquisition, flush out data buffer, but making the final characters in the buffers a special end-of-run word: 0xFF03</dd>

<dt><code>FLUSH</code></dt>
<dd>Flush out the data buffer and send it.</dd>

<dt><code>verbose on</code></dt>
<dd>Sets mode so VME prints out messages it receives.</dd>

<dt><code>verbose off</code></dt>
<dd>Sets mode so VME does NOT print out messages it receives.</dd>

<dt><code>debug on</code></dt>
<dd>Sets mode to debugging, this gives trace print-outs
                  for debugging.</dd>
						
<dt><code>debug off</code></dt>
<dd>Sets mode to NOT debugging, see debug.</dd>
</dl>
<h3>Change Log</h3>
<dl>

<dt>10 Dec 2003 DWV</dt>
<dd>Added a complete description of packets sent by Jam to VME when acquisition is set up.</dd>

<dt>6/16/98 KBS</dt>
<dd>Added Reset to list of commands.<dd>

<dt>4/27/98 DWV</dt>
<dd>Added a command to the protocol indicating end-of-run, distinct from just
stopping acquisition temporarily.</dd>

<dt>4/8/98 JB</dt>
<dd>This file describes the communication in the jam data acquisition program between the host (SUN) computer and the VME computer. The communication is done using udp sockets, udp sockets were chosen for their ease of use. The communication is expected to be realiable, not warranting the over head of tcp 
sockets. There are replies to requests making it easy to verify that communication and execution is occuring. The udp packets are 1024 bytes long.</dd>
</dl>
</BODY>
</HTML>
